{% import 'py2.macros' as py2_macros %}
# This code was generated by FFIG <http://ffig.org>.
# Manual edits will be lost.

import os
from ctypes import *
c_object_p = POINTER(c_void_p)


class {{module.name}}_error(Exception):

    def __init__(self):
        self.value = conf.lib.{{module.name}}_error()
        conf.lib.{{module.name}}_clear_error()

    def __str__(self):
        return self.value
{% for class in classes %}


class {{class.name}}:
{% if not class.is_abstract %}

    @classmethod
    def from_capi(cls, ptr):
        assert(isinstance(ptr, c_object_p))
        if not bool(ptr):
            return None
        return cls(_p=ptr)
    {% for method in class.constructors %}

    def __init__(self, {{py2_macros.constructor_parameters(method, trailing_comma=True)}}_p=None):
        if _p:
            self.ptr = _p
        else:
            self.ptr = c_object_p()
            rc = conf.lib.{{module.name}}_{{ class.name }}_create({{py2_macros.method_arguments(method, trailing_comma=True)}} byref(self.ptr))
            if rc != 0:
                raise {{module.name}}_error()
    {% endfor %}
{% endif %}
{% for method in class.methods %}

    {% if method.is_property %}
    @property
    {% endif %}
    def {{method.name}}(self{{py2_macros.method_parameters(method, leading_comma=True)}}):
    {% if method.returns_void %}
        rc = conf.lib.{{module.name}}_{{class.name}}_{{method.name}}(self{{py2_macros.method_arguments(method, leading_comma=True)}})
        if rc != 0:
            raise {{module.name}}_error()
    {% elif not method.returns_sub_object %}
        rv = {{method.return_type|to_output_py2_ctype}}()
        rc = conf.lib.{{module.name}}_{{class.name}}_{{method.name}}(self{{py2_macros.method_arguments(method, leading_comma=True)}}, byref(rv))
        if rc == 0:
            return rv.value
        raise {{module.name}}_error()
    {% else %}
        rv = c_object_p()
        rc = conf.lib.{{module.name}}_{{class.name}}_{{method.name}}(self{{py2_macros.method_arguments(method, leading_comma=True)}}, byref(rv))
        if rc == 0:
            return {{method.return_type|to_py2_ctype}}.from_capi(rv)
        raise {{module.name}}_error()
    {% endif %}
{% endfor %}

    @classmethod
    def from_param(k, x):
        assert isinstance(x, k)
        return x.ptr

    def __del__(self):
        conf.lib.{{module.name}}_{{class.name}}_dispose(self)
{% for impl in class.impls %}


class {{impl.name}}({{class.name}}):

    @classmethod
    def from_capi(cls, ptr):
        assert(isinstance(ptr, c_object_p))
        if not bool(ptr):
            return None
        return cls(_p=ptr)
    {% for method in impl.constructors %}

    def __init__(self, {{py2_macros.constructor_parameters(method, trailing_comma=True)}} _p=None):
        if _p:
            self.ptr = _p
        else:
            self.ptr = c_object_p()
            rc = conf.lib.{{module.name}}_{{ impl.name }}_create({{py2_macros.method_arguments(method, trailing_comma=True)}} byref(self.ptr))
            if rc != 0:
                raise {{module.name}}_error()
    {% endfor %}
{% endfor %}
{% endfor %}


methodList = [
    ("{{module.name}}_error",
        [],
        c_char_p),
    ("{{module.name}}_clear_error",
        [],
        None),
{% for class in classes %}
    ("{{module.name}}_{{class.name}}_dispose",
        [{{class.name}}],
        None),
{% if not class.is_abstract %}
{% for method in class.constructors %}
    ("{{module.name}}_{{class.name}}_create",
        [{{py2_macros.method_argument_types(method, trailing_comma=True)}}POINTER(c_object_p)],
        c_int),
{% endfor %}
{% endif %}
{% for impl in class.impls %}
{% for method in impl.constructors %}
    ("{{module.name}}_{{ impl.name }}_create",
        [{{py2_macros.method_argument_types(method, trailing_comma=True)}}POINTER(c_object_p)],
        c_int),
{% endfor %}
{% endfor %}
{% for method in class.methods %}
    ("{{module.name}}_{{ class.name }}_{{method.name}}",
        [{{class.name}}{{py2_macros.method_argument_types(method, leading_comma=True)}}{% if not method.returns_void %}, POINTER({{method.return_type|to_output_py2_ctype}}){% endif %}],
        c_int),
{% endfor %}
{% endfor %}
]

# library loading and method registrations
# based on clang python bindings approach


def register_method(lib, item):
    func = getattr(lib, item[0])

    if len(item) >= 2:
        func.argtypes = item[1]

    if len(item) >= 3:
        func.restype = item[2]


class CachedProperty(object):

    def __init__(self, wrapped):
        self.wrapped = wrapped
        try:
            self.__doc__ = wrapped.__doc__
        except:
            pass

    def __get__(self, instance, instance_type=None):
        if instance is None:
            return self

        value = self.wrapped(instance)
        setattr(instance, self.wrapped.__name__, value)

        return value


class Config:
    library_path = None
    loaded = False

    @staticmethod
    def set_library_path(path):
        if Config.loaded:
            raise Exception("library path is already set.")
        Config.library_path = path

    @CachedProperty
    def lib(self):
        lib = self._get_library()
        for m in methodList:
            register_method(lib, m)
        Config.loaded = True
        return lib

    def _get_filename(self):
        import platform
        name = platform.system()

        if name == 'Darwin':
            file = 'lib{{module.name}}_c.dylib'
        elif name == 'Windows':
            file = '{{module.name}}_c.dll'
        else:
            file = 'lib{{module.name}}_c.so'
        return file

    def _get_filepath(self):
        filename = self._get_filename()
        if not Config.library_path:
            return filename
        return os.path.join(Config.library_path, filename)

    def _get_library(self):
        try:
            # Use user-specified library path.
            if Config.library_path:
                library = cdll.LoadLibrary(self._get_filepath())
            else:
                # Use local file
                try:
                    lib_file_dir = os.path.abspath(
                        os.path.dirname(os.path.dirname(__file__)))
                    library = cdll.LoadLibrary(
                        os.path.join(lib_file_dir, self._get_filename()))
                except:
                    # Use system library path (last).
                    library = cdll.LoadLibrary(self._get_filename())
        except OSError as e:
            msg = str(e) + ". To provide a path to {} use Config.set_library_path()".format(self._get_filename())
            raise Exception(msg)

        return library


conf = Config()

