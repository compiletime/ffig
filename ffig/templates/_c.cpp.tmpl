{% import '_c.macros' as c_macros %}
// This code was generated by FFIG <http://ffig.org>.
// Manual edits will be lost.

#include <memory>
#include <string>
#include "{{module.name}}_c.h"
#include "{{module.name}}.h"

static thread_local std::string {{module.name}}_error_;

void {{module.name}}_clear_error()
{
  {{module.name}}_error_.clear();
}

const char* {{module.name}}_error()
{
  return {{module.name}}_error_.c_str();
}

namespace {
{% for class in classes %}
  using {{class.name}}_ptr = const std::shared_ptr<{{class.impl_name}}>*;
{% endfor %}
} // end anonymous namespace

{% for class in classes %}
void {{module.name}}_{{ class.name }}_dispose({{module.name}}_{{class.name}} my{{class.name}})
{
  delete static_cast<{{class.name}}_ptr>(my{{class.name}});
}
{% if not class.is_abstract %}
{% for method in class.constructors %}

int {{module.name}}_{{class.name}}_create(
    {{c_macros.method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* rv)
{
    try
    {
        auto p = std::make_unique<const {{class.impl_name}}>({{c_macros.method_arguments(method)}});
        *rv = new std::shared_ptr<const {{class.impl_name}}>(p.release());
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% if method.is_noexcept %}

{{module.name}}_{{class.name}} {{module.name}}_{{ class.name }}_create_noexcept(
    {{c_macros.method_parameters(module, method)}}) 
{
    auto p = std::make_unique<const {{class.impl_name}}>({{c_macros.method_arguments(method)}});
    return new std::shared_ptr<const {{class.impl_name}}>(p.release());
}
{% endif %}
{% endfor %}
{% endif %}
{% for method in class.methods %}

int {{module.name}}_{{class.name}}_{{method.name}}(
    {{module.name}}_{{class.name}} my{{class.name}}
    {% if method.returns_void %}
    {{c_macros.method_parameters(module, method, leading_comma=True)}}
    {% else %}
    {{c_macros.method_parameters(module, method, leading_comma=True, trailing_comma=False)}},
    {{method.return_type | to_c(module.name)}}* rv
    {% endif %}
    )
{
    try
    {
        {% if method.returns_void %}
        (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.impl_name}}(
            {{c_macros.method_arguments(method)}});
        {% elif not method.returns_sub_object %}
        *rv = (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.impl_name}}(
            {{c_macros.method_arguments(method)}});
        {% else %}
        auto p = static_cast<const {{class.name}}_ptr>(my{{class.name}});
        auto subobj = (*p)->{{method.impl_name}}(
            {{c_macros.method_arguments(method)}});
        {% if method.returns_nullable %}
        if (!subobj)
        {
            *rv = nullptr;
            return {{module.name}}_RC_SUCCESS;
        }
        {% endif %}
        *rv = new std::shared_ptr<{{method.return_type.pointee}}>(*p, subobj);
        {% endif %}
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% if method.is_noexcept %}

EXPORT {{method.return_type | to_c(module.name)}} {{module.name}}_{{ class.name }}_{{method.name}}_noexcept(
    {{module.name}}_{{class.name}} my{{class.name}} {{c_macros.method_parameters(module, method, leading_comma=True)}})
{
    {% if method.returns_void %}
    (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.impl_name}}(
        {{c_macros.method_arguments(method)}});
    {% elif not method.returns_sub_object %}
    return (*static_cast<{{class.name}}_ptr>(my{{class.name}}))->{{method.impl_name}}(
        {{c_macros.method_arguments(method)}});
    {% else %}
    auto p = static_cast<const {{class.name}}_ptr>(my{{class.name}});
    auto subobj = (*p)->{{method.impl_name}}(
        {{c_macros.method_arguments(method)}});
    {% if method.returns_nullable %}
    if (!subobj)
    {
        return nullptr;
    }
    {% endif %}
    return new std::shared_ptr<{{method.return_type.pointee}}>(*p, subobj);
    {% endif %}
}
{% endif %}
{% endfor %}
{% for impl in class.impls %}
{% for method in impl.constructors %}

int {{module.name}}_{{impl.name}}_create(
    {{c_macros.method_parameters(module, method, trailing_comma=True)}}
    {{module.name}}_{{class.name}}* rv)
{
    try
    {
        auto p = std::make_unique<const {{impl.impl_name}}>({{c_macros.method_arguments(method)}});
        *rv = new std::shared_ptr<const {{class.impl_name}}>(p.release());
    }
    catch (const std::exception& e)
    {
        {{module.name}}_error_ = e.what();
        return {{module.name}}_RC_FAIL;
    }
    return {{module.name}}_RC_SUCCESS;
}
{% if method.is_noexcept %}

{{module.name}}_{{class.name}} {{module.name}}_{{impl.name}}_create_noexcept(
    {{c_macros.method_parameters(module, method)}}) 
{
    auto p = std::make_unique<const {{impl.impl_name}}>({{c_macros.method_arguments(method)}});
    return new std::shared_ptr<const {{class.impl_name}}>(p.release());
}
{% endif %}
{% endfor %}
{% endfor %}
{% endfor %}
